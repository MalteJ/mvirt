# mvirt-log

`mvirt-log` is the centralized logging and audit service for the mvirt ecosystem. It is designed for high-throughput ingestion and structured historical queries.

## Purpose

- **Audit Trail:** Immutable record of actions and lifecycle events.
- **Many-to-Many Correlation:** A single log entry (e.g., "Disk attached") is indexed under multiple entities (The VM, The Disk, The User).
- **Performance:** Optimized for write-heavy workloads using Log-Structured Merge Trees (LSM).

## Architecture

`mvirt-log` runs as a standalone daemon exposing a gRPC API.

### Tech Stack
- **Language:** Rust
- **Communication:** gRPC (tonic)
- **Storage Engine:** [fjall](https://github.com/fjall-rs/fjall) (LSM-Tree, Pure Rust)

### Storage Design (Schema)

We use a Key-Value approach with manual indexing. We utilize `fjall` partitions to separate data from indexes.

#### 1. Partition: `logs_data` (The Source of Truth)
Stores the full log content time-ordered.

- **Key:** `[Timestamp (BigEndian u64)]` + `[LogID (ULID/UUIDv7)]`
  - *BigEndian ensures byte-level sorting matches chronological order.*
- **Value:** `[Protobuf Serialization of LogEntry]`

#### 2. Partition: `index_objects` (Inverted Index)
Allows finding logs relevant to specific objects (VMs, Disks, NICs).

- **Key:** `[ObjectID (String bytes)]` + `[Timestamp (BigEndian u64)]` + `[LogID]`
- **Value:** `(empty)`

### Consistency Model: Atomic Batches

To ensure that logs and their corresponding indexes never drift apart (avoiding race conditions), we use **Atomic Batches**.

**Write Path:**
1.  Ingest `LogEntry` (containing timestamp, message, and list of `related_object_ids`).
2.  Open a new Write Batch.
3.  Add `LogEntry` to `logs_data`.
4.  For each ID in `related_object_ids`:
    - Add entry to `index_objects` (Key: `ID + Timestamp + LogID`).
5.  **Commit Batch.**

This guarantees **ACID properties**: The log is either fully persisted and fully indexed, or not persisted at all.

## API Design (Draft)

```protobuf
syntax = "proto3";
package mvirt.log;

service LogService {
  rpc Log(LogRequest) returns (LogResponse);
  rpc Query(QueryRequest) returns (stream LogEntry);
}

message LogEntry {
  // Generated by server if empty
  bytes id = 1; 
  int64 timestamp_ns = 2;
  
  string message = 3;
  LogLevel level = 4;
  string component = 5; // e.g. "vmm", "cli"

  // The simplified many-to-many link. 
  // Any object ID mentioned here will be indexed.
  // e.g. ["vm-123", "disk-456", "req-789"]
  repeated string related_object_ids = 6; 
  
  map<string, string> labels = 7;
}

message QueryRequest {
  // If set, performs a prefix scan on the index partition
  // e.g. "vm-123"
  optional string object_id = 1;
  
  int64 start_time_ns = 2;
  int64 end_time_ns = 3;
  uint32 limit = 4;
  bool follow = 5; // Live tail
}

enum LogLevel {
  INFO = 0;
  WARN = 1;
  ERROR = 2;
  DEBUG = 3;
  AUDIT = 4;
}

message LogRequest { LogEntry entry = 1; }
message LogResponse { bytes id = 1; }
```

## Usage

```bash
# Start the logging service
mvirt-log --listen [::1]:50052 --data-dir /var/lib/mvirt-log

# Custom data directory
mvirt-log --data-dir ./log-data
```

## Options

| Option | Default | Description |
|--------|---------|-------------|
| `--listen` | `[::1]:50052` | gRPC listen address |
| `--data-dir` | `/var/lib/mvirt-log` | Data directory for log storage |

## Data Directory

```
<data-dir>/
└── fjall/          # LSM-Tree storage (logs_data + index_objects)
```

## Building

```bash
cargo build -p mvirt-log
```

## See Also

- [Architecture](../docs/architecture.md) - System overview
- [CLAUDE.md](../CLAUDE.md) - Logging guidelines and AuditLogger usage