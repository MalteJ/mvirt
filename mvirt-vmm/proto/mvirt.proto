syntax = "proto3";
package mvirt;

// ============================================
// Core Types
// ============================================

enum VmState {
  VM_STATE_UNSPECIFIED = 0;
  VM_STATE_STOPPED = 1;
  VM_STATE_STARTING = 2;
  VM_STATE_RUNNING = 3;
  VM_STATE_STOPPING = 4;
}

message Vm {
  string id = 1;
  optional string name = 2;
  VmState state = 3;
  VmConfig config = 4;
  int64 created_at = 5;
  optional int64 started_at = 6;
}

enum BootMode {
  BOOT_MODE_UNSPECIFIED = 0;
  BOOT_MODE_DISK = 1;    // Boot from disk using firmware (UEFI)
  BOOT_MODE_KERNEL = 2;  // Direct kernel boot
}

message VmConfig {
  uint32 vcpus = 1;
  uint64 memory_mb = 2;

  // Boot configuration
  BootMode boot_mode = 9;         // DISK or KERNEL boot
  optional string kernel = 3;     // Required for KERNEL boot
  optional string initramfs = 4;  // Optional, for KERNEL boot
  optional string cmdline = 5;    // Optional, for KERNEL boot

  repeated DiskConfig disks = 6;
  repeated NicConfig nics = 7;
  optional string user_data = 8;  // cloud-init user-data (YAML content)

  // CPU features
  bool nested_virt = 10;          // Enable nested virtualization
}

message DiskConfig {
  string path = 1;
  bool readonly = 2;
}

message NicConfig {
  optional string tap = 1;           // TAP device name (legacy, auto-created if empty)
  optional string mac = 2;           // MAC address
  optional string vhost_socket = 3;  // vhost-user socket path (from mvirt-net)
}

// ============================================
// VM Service
// ============================================

service VmService {
  // System
  rpc GetVersion(GetVersionRequest) returns (VersionInfo);
  rpc GetSystemInfo(GetSystemInfoRequest) returns (SystemInfo);

  // CRUD
  rpc CreateVm(CreateVmRequest) returns (Vm);
  rpc GetVm(GetVmRequest) returns (Vm);
  rpc ListVms(ListVmsRequest) returns (ListVmsResponse);
  rpc DeleteVm(DeleteVmRequest) returns (DeleteVmResponse);

  // Lifecycle
  rpc StartVm(StartVmRequest) returns (Vm);
  rpc StopVm(StopVmRequest) returns (Vm);
  rpc KillVm(KillVmRequest) returns (Vm);

  // Hot-plug (Phase 2)
  rpc AttachDisk(AttachDiskRequest) returns (Vm);
  rpc DetachDisk(DetachDiskRequest) returns (Vm);
  rpc AttachNic(AttachNicRequest) returns (Vm);
  rpc DetachNic(DetachNicRequest) returns (Vm);

  // Console
  rpc Console(stream ConsoleInput) returns (stream ConsoleOutput);

  // Events
  rpc WatchVms(WatchVmsRequest) returns (stream VmEvent);
}

// ============================================
// Request/Response Messages
// ============================================

// System

message GetVersionRequest {}

message VersionInfo {
  string version = 1;
}

message GetSystemInfoRequest {}

message SystemInfo {
  // Basic info (existing)
  uint32 total_cpus = 1;
  uint64 total_memory_mb = 2;
  uint32 allocated_cpus = 3;
  uint64 allocated_memory_mb = 4;
  float load_1 = 5;
  float load_5 = 6;
  float load_15 = 7;

  // Detailed system info (new)
  HostInfo host = 10;
  CpuInfo cpu = 11;
  MemoryInfo memory = 12;
  repeated NumaNode numa_nodes = 13;
  repeated DiskInfo disks = 14;
  repeated NicInfo nics = 15;
}

message HostInfo {
  string hostname = 1;
  string kernel_version = 2;
  uint64 uptime_seconds = 3;
}

message CpuInfo {
  string model = 1;
  string vendor = 2;
  uint32 physical_cores = 3;
  uint32 logical_cores = 4;
  uint32 sockets = 5;
  repeated CpuCore cores = 6;
  repeated string flags = 7;  // vmx, svm, aes, etc.
}

message CpuCore {
  uint32 id = 1;
  uint64 frequency_mhz = 2;
  float usage_percent = 3;
  uint32 numa_node = 4;
}

message MemoryInfo {
  uint64 total_bytes = 1;
  uint64 available_bytes = 2;
  uint64 cached_bytes = 3;
  uint64 swap_total_bytes = 4;
  uint64 swap_used_bytes = 5;
  uint64 hugepages_total = 6;
  uint64 hugepages_free = 7;
  uint64 hugepage_size_kb = 8;
}

message NumaNode {
  uint32 id = 1;
  uint64 total_memory_bytes = 2;
  uint64 free_memory_bytes = 3;
  repeated uint32 cpu_ids = 4;
}

message DiskInfo {
  string device = 1;
  string model = 2;
  string serial = 3;
  uint64 size_bytes = 4;
  bool smart_available = 5;
  bool smart_healthy = 6;
  optional int32 temperature_celsius = 7;
  optional uint64 power_on_hours = 8;
}

message NicInfo {
  string name = 1;
  string mac = 2;
  bool is_up = 3;
  optional uint32 speed_mbps = 4;
  string duplex = 5;
  repeated string ipv4 = 6;
  repeated string ipv6 = 7;
  string driver = 8;
  uint64 rx_bytes = 9;
  uint64 tx_bytes = 10;
}

// CRUD

message CreateVmRequest {
  optional string name = 1;
  VmConfig config = 2;
}

message GetVmRequest {
  string id = 1;
}

message ListVmsRequest {}

message ListVmsResponse {
  repeated Vm vms = 1;
}

message DeleteVmRequest {
  string id = 1;
}

message DeleteVmResponse {}

// Lifecycle

message StartVmRequest {
  string id = 1;
}

message StopVmRequest {
  string id = 1;
  uint32 timeout_seconds = 2;
}

message KillVmRequest {
  string id = 1;
}

// Hot-plug

message AttachDiskRequest {
  string vm_id = 1;
  DiskConfig disk = 2;
}

message DetachDiskRequest {
  string vm_id = 1;
  string path = 2;
}

message AttachNicRequest {
  string vm_id = 1;
  NicConfig nic = 2;
}

message DetachNicRequest {
  string vm_id = 1;
  string mac = 2;
}

// Console

message ConsoleInput {
  string vm_id = 1;
  bytes data = 2;
}

message ConsoleOutput {
  bytes data = 1;
}

// Events

message WatchVmsRequest {
  optional string vm_id = 1;
}

message VmEvent {
  string vm_id = 1;
  VmEventType type = 2;
  int64 timestamp = 3;
  optional Vm vm = 4;
}

enum VmEventType {
  VM_EVENT_UNSPECIFIED = 0;
  VM_EVENT_CREATED = 1;
  VM_EVENT_STARTED = 2;
  VM_EVENT_STOPPED = 3;
  VM_EVENT_DELETED = 4;
}
